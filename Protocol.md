# 통신 프로토콜 문서

이 문서는 `Com_Protocol` 클래스에서 구현한 통신 프로토콜의 패킷 구조와 명령어(CMD) 구분에 대해 설명합니다.

---

## 1. 패킷 구조

패킷은 아래와 같은 순서와 형식으로 구성됩니다.

### 1.1. 전체 패킷 구성

```
+------------------+------------------+-------------------+----------------+-----------------+
| Start Sequence   | Packet Length    | Header            | Payload        | CRC16           |
| (4 바이트)       | (2 바이트)       | (6 바이트)        | (가변 길이)    | (2 바이트)      |
+------------------+------------------+-------------------+----------------+-----------------+
```

각 필드의 역할은 다음과 같습니다.

### 1.2. Start Sequence

* **길이** : 4 바이트
* **값** : 0x16 (4회 연속 전송)
* **목적** : 패킷의 시작을 알리는 시퀀스

### 1.3. Packet Length

* **길이** : 2 바이트 (빅 엔디안)
* **내용** : 이후 전송되는 데이터의 총 길이
* **구성** : Header (6 바이트) + Payload (가변 길이) + CRC (2 바이트)
* **계산식** : `총 길이 = 8 + Payload 길이`

### 1.4. Header

* **길이** : 6 바이트
* **구성 필드** :
* **수신자 ID (Receiver ID)** : 2 바이트 (빅 엔디안)
* **송신자 ID (Sender ID)** : 2 바이트 (빅 엔디안)
* **명령어 (CMD)** : 2 바이트 (빅 엔디안)

### 1.5. Payload

* **길이** : 가변 (Payload 길이 = `총 길이 - 8` 바이트)
* **내용** : 명령에 따라 달라지는 데이터

### 1.6. CRC (Cyclic Redundancy Check)

* **길이** : 2 바이트
* **계산 대상** : Header (6 바이트)와 Payload, Length 제외
* **계산 알고리즘** : CRC16 (XMODEM 방식)
* **초기값** : 0x0000
* **다항식** : 0x1021
* **방법** : 256-entry Lookup Table을 사용하여 계산

---

## 2. 패킷 수신 상태 머신

수신 측에서는 데이터를 아래와 같은 상태 머신으로 처리합니다.

1. **WAIT_START**
   * Start Sequence (0x16 4회)를 기다림
   * 올바른 시퀀스가 수신되면 다음 상태로 전환
2. **READ_LENGTH**
   * 2 바이트의 Packet Length를 읽음
   * 읽은 길이에 따라 이후 데이터를 처리
3. **READ_RECEIVER_ID**
   * 2 바이트의 수신자 ID를 읽음
4. **READ_SENDER_ID**
   * 2 바이트의 송신자 ID를 읽음
5. **READ_CMD**
   * 2 바이트의 명령어(CMD)를 읽음
6. **READ_PAYLOAD**
   * `Packet Length - 6` 바이트를 읽어 Header 이후의 Payload 및 CRC를 수신
   * 마지막 2 바이트를 **CRC**로 분리하고,
   * Header와 Payload를 대상으로 CRC16 계산 후 수신된 CRC와 비교
   * CRC 검증에 성공하면 `processCommand()`를 호출하여 명령어를 처리

> **참고:** 패킷 수신 도중, 타임아웃(예: 100ms) 이 발생하면 상태 머신은 `WAIT_START` 상태로 리셋됩니다.

---

## 3. 명령어 (CMD) 구분

패킷의 Header 내 CMD 필드를 통해 다음과 같은 명령어가 구분됩니다.

명령어 범위 0x0000~0x7FFF

0~32767

응답은 요청 cmd에 0x8000 을 or 처리하여 사용

### 3.1. CMD_PING (0x0001)

* **설명** :
* 핑(PING) 요청을 전송하여 연결 상태를 확인하는 명령어입니다.
* **Payload** :
* 일반적으로 ASCII 문자열 `"PING"` (4 바이트)를 포함합니다.
* **응답** :
* 핑 요청을 받은 장치는 응답으로 CMD_PONG (0x8001) 명령어를 전송하며, `"PONG"` 문자열을 Payload로 포함합니다.

### 3.2. CMD_PONG (0x8001)

* **설명** :
* 핑 요청(CMD_PING)에 대한 응답으로 전송되는 명령어입니다.
* **Payload** :
* 일반적으로 ASCII 문자열 `"PONG"` (4 바이트)를 포함합니다.

### 3.3. CMD_FILE_RECEIVE (0x0002)

* **설명** :
* 파일 전송을 위한 명령어로, 파일 수신의 여러 단계를 포함합니다.
* **파일 전송 관련 단계 (File Transfer Stage)** :

#### 3.3.1. REQUEST_RECEIVE (Stage 1)

* **Payload 포맷** :
  * `[Stage (1 바이트), File Size (4 바이트)]`
* **설명** :
  * 파일 수신 요청을 나타내며, 수신 측에서는 파일 크기가 허용 범위(최대 1MB) 내에 있는지 확인합니다.
* **처리** :
  * 조건에 따라 성공/실패 응답(ACK)을 전송합니다.

#### 3.3.2. RECEIVING_DATA (Stage 3)

* **Payload 포맷** :
  * `[Stage (1 바이트), Block Index (4 바이트), Data (가변)]`
* **설명** :
  * 파일의 데이터 블록을 전송하는 단계입니다.
* **처리** :
  * 수신 측에서는 현재 기대하는 블록 인덱스와 비교하여 데이터의 순서를 확인하고,
  * 데이터 블록에 대한 CRC16 계산을 수행합니다.
* **응답** :
  * 올바른 경우 ACK를 전송하며, 블록 인덱스를 포함할 수 있습니다.

#### 3.3.3. VERIFY_CHECKSUM (Stage 4)

* **Payload 포맷** :
  * `[Stage (1 바이트), Received Checksum (2 바이트)]`
* **설명** :
  * 전송 완료 후 파일의 무결성을 확인하기 위한 체크섬 검증 단계입니다.
* **처리** :
  * 수신 측에서 계산한 체크섬과 전달받은 체크섬을 비교합니다.
* **응답** :
  * 체크섬이 일치하면 최종 ACK를 전송하고, 파일 수신을 완료합니다.

### 3.4. CMD_FILE_RECEIVE_ACK (0x8002)

* **설명** :
* 파일 전송 과정의 각 단계에 대해 수신(또는 전송) ACK를 나타내는 명령어입니다.
* **Payload 포맷** :
* `[Stage (1 바이트), Success Flag (1 바이트), (선택적) Block Index (4 바이트)]`
  * **Success Flag** : 1 (성공), 0 (실패)
  * Block Index: 데이터 블록 전송 시, 현재 블록 인덱스 정보가 포함될 수 있습니다.

### 3.5. CMD_CONFIG (0x0003)

* **설명** :
* 시스템 또는 장비의 설정(configuration)을 위한 명령어입니다.
* **Payload** :
* 구체적인 포맷은 응용 프로그램에 따라 정의됩니다.
* **처리** :
* CMD_CONFIG 수신 시, `handleConfig()` 함수가 호출되며,
* 필요에 따라 사용자 정의 기능으로 오버라이드(override)하여 구현합니다.

### 3.6. CMD_STATUS_SYNC (0x0100)
* **설명** :
* 장비의 상태 동기화를 위한 명령어입니다.
* **Payload** : 없음

### 3.7. CMD_STATUS_SYNC_ACK (0x8100)
* **설명** :
* 장비의 상태 응답 입니다다.
* **Payload** :
* **Payload 포맷** :
  * `[Hours (1 바이트), Minutes (1 바이트), Seconds (1 바이트), Current Count (2 바이트), Total Count (2 바이트), Voltage (2 바이트), Current (2 바이트)]`
  * 총 11 바이트 길이
* **필드 설명** :
  * Hours/Minutes/Seconds : 연속 구동 시간 (시/분/초)
  * Current Count : 현재 동작 회차 (2 바이트, 빅 엔디안)
  * Total Count : 총 동작 회차 (2 바이트, 빅 엔디안)
  * Voltage : 전압값 (2 바이트, 빅 엔디안, 단위: 0.01V)
  * Current : 전류값 (2 바이트, 빅 엔디안, 단위: 0.01A)
* **예시** :
  * 전압 3000 (0x0BB8) = 30.00V
  * 전류 4000 (0x0FA0) = 40.00A

* **처리** :

### 3.8. CMD_MAIN_POWER_CONTROL (0x0100)
* **설명** :
* 장비의 메인 전원 제어를 위한 명령어입니다.
* **Payload** : payload[0] = 0x01 : ON, payload[0] = 0x00 : OFF

### 3.9. CMD_MAIN_POWER_CONTROL_ACK (0x8101)
* **설명** :
* 장비의 메인 전원 제어 응답 입니다. 제어 결과로 전송됩니다.
* **Payload** : payload[0] = 0x01 : ON, payload[0] = 0x00 : OFF

---

## 4. 추가 참고 사항

* **바이트 순서 (Endianness)** :
* 모든 멀티 바이트 필드(패킷 길이, 수신자 ID, 송신자 ID, CMD, 파일 크기, 블록 인덱스, CRC 등)는 빅 엔디안 형식으로 전송됩니다.
* **오류 처리** :
* 수신된 패킷의 CRC 검증에 실패할 경우 해당 패킷은 폐기됩니다.
* 파일 전송 시, 단계별 오류(예: 파일 크기 초과, 블록 인덱스 불일치, 체크섬 불일치 등)에 대해 실패 ACK가 전송됩니다.
* **타임아웃** :
* 패킷 수신 도중 일정 시간(예: 100ms) 동안 데이터가 도착하지 않으면 상태 머신이 리셋되어 올바른 패킷 수신을 보장합니다.

---
